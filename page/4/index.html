<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=consolas:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/themes/blue/pace-theme-minimal.css">
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.8.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"disqus","storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="Be smart! Keep Learning">
<meta property="og:type" content="website">
<meta property="og:title" content="YAN&#39;s Blog">
<meta property="og:url" content="http://example.com/page/4/index.html">
<meta property="og:site_name" content="YAN&#39;s Blog">
<meta property="og:description" content="Be smart! Keep Learning">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="YAN">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/page/4/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"page/4/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>YAN's Blog</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">YAN's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="YAN"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">YAN</p>
  <div class="site-description" itemprop="description">Be smart! Keep Learning</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">44</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/applepieiris" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/30/TensorFlow-Advanced-Techniques-Specialization%E4%B8%93%E9%A1%B9%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="YAN">
      <meta itemprop="description" content="Be smart! Keep Learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YAN's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/30/TensorFlow-Advanced-Techniques-Specialization%E4%B8%93%E9%A1%B9%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">TensorFlow-Advanced-Techniques-Specialization专项课程总结</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-30 11:40:11" itemprop="dateCreated datePublished" datetime="2022-08-30T11:40:11+08:00">2022-08-30</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2022-09-16 10:44:12" itemprop="dateModified" datetime="2022-09-16T10:44:12+08:00">2022-09-16</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">深度学习</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>22k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>20 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="course-1-custom-modelslayers-and-loss-functions">Course 1:
Custom Models,Layers and loss Functions</h1>
<h2 id="多输出-multi-output">多输出 multi output</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define model layers.</span></span><br><span class="line">input_layer = Input(shape=(<span class="built_in">len</span>(train.columns),))</span><br><span class="line">first_dense = Dense(units=<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(input_layer)</span><br><span class="line">second_dense = Dense(units=<span class="number">128</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(first_dense)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Y1 output will be fed directly from the second dense</span></span><br><span class="line">y1_output = Dense(units=<span class="string">&#x27;1&#x27;</span>, name=<span class="string">&#x27;y1_output&#x27;</span>)(second_dense)</span><br><span class="line">third_dense = Dense(units=<span class="string">&#x27;64&#x27;</span>, activation=<span class="string">&#x27;relu&#x27;</span>)(second_dense)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Y2 output will come via the third dense</span></span><br><span class="line">y2_output = Dense(units=<span class="string">&#x27;1&#x27;</span>, name=<span class="string">&#x27;y2_output&#x27;</span>)(third_dense)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the model with the input layer and a list of output layers</span></span><br><span class="line">model = Model(inputs=input_layer, outputs=[y1_output, y2_output])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the optimizer, and compile the model with loss functions for both outputs</span></span><br><span class="line">optimizer = tf.keras.optimizers.SGD(learning_rate=<span class="number">0.001</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(optimizer=optimizer,</span><br><span class="line">              loss=&#123;<span class="string">&#x27;y1_output&#x27;</span>: <span class="string">&#x27;mse&#x27;</span>, <span class="string">&#x27;y2_output&#x27;</span>: <span class="string">&#x27;mse&#x27;</span>&#125;,</span><br><span class="line">              metrics=&#123;<span class="string">&#x27;y1_output&#x27;</span>: tf.keras.metrics.RootMeanSquaredError(),</span><br><span class="line">                       <span class="string">&#x27;y2_output&#x27;</span>: tf.keras.metrics.RootMeanSquaredError()&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意在这种多输出的模型架构下，train_y是一个元组set</p>
<h2 id="自定义loss-function">自定义loss function</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">huber_loss</span>(<span class="params">y_true , y_pred</span>):</span> <span class="comment"># y_true在前，y_pred在后</span></span><br><span class="line">    thresold = <span class="number">1</span></span><br><span class="line">    error = y_true - y_pred</span><br><span class="line">    return_type = tf.<span class="built_in">abs</span>(error) &lt;= thresold</span><br><span class="line">    r1 = <span class="number">0.5</span> * tf.square(error)</span><br><span class="line">    r2 = thresold * (tf.<span class="built_in">abs</span>(error) - (<span class="number">0.5</span>*thresold))</span><br><span class="line">    <span class="keyword">return</span> tf.where(return_type , r1 , r2)</span><br><span class="line"></span><br><span class="line">model_huber_loss = tf.keras.models.Model(inputs=<span class="built_in">input</span> , outputs=output_layer)</span><br><span class="line">model_huber_loss.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;sgd&quot;</span> , loss=huber_loss)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果loss function有需要传递别的除了y_ture,y_pred参数： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">huber_loss_wrapper</span>(<span class="params">thresold</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">huber_loss</span>(<span class="params">y_true , y_pred</span>):</span></span><br><span class="line">        error = y_true - y_pred</span><br><span class="line">        return_type = tf.<span class="built_in">abs</span>(error) &lt;= thresold</span><br><span class="line">        r1 = <span class="number">0.5</span> * tf.square(error)</span><br><span class="line">        r2 = thresold * (tf.<span class="built_in">abs</span>(error) - (<span class="number">0.5</span>*thresold))</span><br><span class="line">        <span class="keyword">return</span> tf.where(return_type , r1 , r2)</span><br><span class="line">    <span class="keyword">return</span> huber_loss</span><br><span class="line">model_huber_loss_wrapper = tf.keras.models.Model(inputs=<span class="built_in">input</span> , outputs=output_layer)</span><br><span class="line">model_huber_loss_wrapper.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;sgd&quot;</span> , loss=huber_loss_wrapper(thresold=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>
也可以将loss写成tensorflow.keras.losses的继承类： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense , Input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.losses <span class="keyword">import</span> Loss</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huber</span>(<span class="params">Loss</span>):</span></span><br><span class="line">    thresold = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , thresold</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.thresold = thresold</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self , y_true , y_pred</span>):</span></span><br><span class="line">        error = y_true - y_pred</span><br><span class="line">        return_type = tf.<span class="built_in">abs</span>(error) &lt;= self.thresold</span><br><span class="line">        r1 = <span class="number">0.5</span> * tf.square(error)</span><br><span class="line">        r2 = self.thresold * (tf.<span class="built_in">abs</span>(error) - (<span class="number">0.5</span>*self.thresold))</span><br><span class="line">        <span class="keyword">return</span> tf.where(return_type , r1 , r2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">input</span> = Input(shape=(<span class="number">1</span>,) , name=<span class="string">&quot;input_layer&quot;</span>)</span><br><span class="line">output_layer = Dense(<span class="number">1</span> , name=<span class="string">&quot;output_layer&quot;</span>)(<span class="built_in">input</span>)</span><br><span class="line">model_huber_loss_class = tf.keras.models.Model(inputs=<span class="built_in">input</span> , outputs=output_layer)</span><br><span class="line"></span><br><span class="line">model_huber_loss_class.<span class="built_in">compile</span>(optimizer=<span class="string">&quot;sgd&quot;</span> , loss=Huber(thresold=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">model_huber_loss_class.fit(xs,ys,epochs=<span class="number">500</span>,verbose=<span class="number">0</span>)</span><br><span class="line">model_huber_loss_class.predict([[<span class="number">10.0</span>]])</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="custom-layers-自定义层">custom layers 自定义层</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.nn <span class="keyword">import</span> softmax , relu</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDenseLayerwithActivation</span>(<span class="params">Layer</span>):</span> <span class="comment"># 可以传递units,activation</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self , units = <span class="number">32</span> ,activation = <span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MyDenseLayerwithActivation , self).__init__()</span><br><span class="line">        self.units = units</span><br><span class="line">        self.activation = activation</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build</span>(<span class="params">self , input_shape</span>):</span></span><br><span class="line">        w_init = tf.random_normal_initializer()</span><br><span class="line">        b_init = tf.zeros_initializer()</span><br><span class="line"></span><br><span class="line">        self.w = tf.Variable(initial_value=w_init(shape=(input_shape[-<span class="number">1</span>] , self.units) , dtype=<span class="string">&quot;float32&quot;</span>) , trainable=<span class="literal">True</span> , name=<span class="string">&quot;kernal&quot;</span>)</span><br><span class="line">        self.b = tf.Variable(initial_value=b_init(shape=(self.units , ) , dtype=<span class="string">&quot;float32&quot;</span>) , trainable=<span class="literal">True</span> , name=<span class="string">&quot;bias&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self , inputs</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.activation( tf.matmul(inputs , self.w) + self.b )</span><br><span class="line"></span><br><span class="line">model_simpledense_activation = Sequential([</span><br><span class="line">    Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)),</span><br><span class="line">    MyDenseLayerwithActivation(units = <span class="number">128</span> , activation=relu),</span><br><span class="line">    MyDenseLayerwithActivation(<span class="number">10</span> , activation = softmax)</span><br><span class="line">])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="lambda-layer">lambda layer</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model_lambda = tf.keras.models.Sequential([</span><br><span class="line">    tf.keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">128</span>),</span><br><span class="line">    tf.keras.layers.Lambda(<span class="keyword">lambda</span> x : tf.<span class="built_in">abs</span>(x)),</span><br><span class="line">    tf.keras.layers.Dense(<span class="number">10</span> , activation=<span class="string">&#x27;softmax&#x27;</span>)</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<h2 id="自定义model">自定义model</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.layers <span class="keyword">import</span> Dense , Input , concatenate</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model</span><br><span class="line"><span class="keyword">from</span> tensorflow.nn <span class="keyword">import</span> relu </span><br><span class="line"><span class="keyword">from</span> tensorflow.python.keras.utils.vis_utils <span class="keyword">import</span> plot_model</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOwnModel</span>(<span class="params">Model</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,units = <span class="number">30</span> , activation = <span class="string">&quot;relu&quot;</span> , **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.hidden1 = Dense(units , activation=activation , name=<span class="string">&quot;hidden1&quot;</span>)</span><br><span class="line">        self.hidden2 = Dense(units , activation=activation , name=<span class="string">&quot;hidden2&quot;</span>)</span><br><span class="line">        self.main_output = Dense(<span class="number">1</span>)</span><br><span class="line">        self.aux_output = Dense(<span class="number">1</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>(<span class="params">self , inputs</span>):</span></span><br><span class="line">        input_l , input_r = inputs</span><br><span class="line">        hidden1 = self.hidden1(input_r)</span><br><span class="line">        hidden2 = self.hidden2(hidden1)</span><br><span class="line">        concat = concatenate([input_l , hidden2])</span><br><span class="line">        main_output = self.main_output(concat)</span><br><span class="line">        aux_output  = self.aux_output(hidden2)</span><br><span class="line">        <span class="keyword">return</span> main_output , aux_output</span><br><span class="line"></span><br><span class="line">model = MyOwnModel()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="callbacks">callbacks</h2>
<h3 id="使用tensorboard">使用tensorboard</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> TensorBoard</span><br><span class="line">model = build_model(dense_units=<span class="number">256</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">  </span><br><span class="line">logdir = os.path.join(<span class="string">&quot;logs&quot;</span>, datetime.datetime.now().strftime(<span class="string">&quot;%Y%m%d-%H%M%S&quot;</span>))</span><br><span class="line">tensorboard_callback = tf.keras.callbacks.TensorBoard(logdir)</span><br><span class="line"></span><br><span class="line">model.fit(train_batches, </span><br><span class="line">          epochs=<span class="number">10</span>, </span><br><span class="line">          validation_data=validation_batches, </span><br><span class="line">          callbacks=[tensorboard_callback])</span><br></pre></td></tr></table></figure>
<p>模型训练完之后使用<code>tensorboard --logdir logs</code>来查看模型训练过程中的loss和acc
。
上面这种方式不太适合在服务器调试model，一般采取checkpoint的方式以一定的时间间隔保存模型参数。
### 使用ModelCheckpoint</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> EarlyStopping, LearningRateScheduler, ModelCheckpoint, CSVLogger, ReduceLROnPlateau</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># method 1:</span></span><br><span class="line">model = build_model(dense_units=<span class="number">256</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">  </span><br><span class="line">model.fit(train_batches, </span><br><span class="line">          epochs=<span class="number">5</span>, </span><br><span class="line">          validation_data=validation_batches, </span><br><span class="line">          verbose=<span class="number">2</span>,</span><br><span class="line">          callbacks=[ModelCheckpoint(<span class="string">&#x27;weights.&#123;epoch:02d&#125;-&#123;val_loss:.2f&#125;.h5&#x27;</span>, verbose=<span class="number">1</span>), <span class="comment"># 这样调用会保存多个文件，每个epoch结束时更新文件</span></span><br><span class="line">          ])</span><br><span class="line"></span><br><span class="line"><span class="comment"># method2:</span></span><br><span class="line">model = build_model(dense_units=<span class="number">256</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">  </span><br><span class="line">model.fit(train_batches, </span><br><span class="line">          epochs=<span class="number">2</span>, </span><br><span class="line">          validation_data=validation_batches, </span><br><span class="line">          verbose=<span class="number">2</span>,</span><br><span class="line">          callbacks=[ModelCheckpoint(<span class="string">&#x27;./saved_model&#x27;</span>, verbose=<span class="number">1</span>) <span class="comment"># 如果传入的是一个文件夹，会在文件夹内创建多个文件</span></span><br><span class="line">          ])</span><br></pre></td></tr></table></figure>
<h3 id="earlystoppingcsvloggerlearningrateschedulerreducelronplateau">EarlyStopping,CSVLogger,LearningRateScheduler,ReduceLROnPlateau</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#EarlyStopping</span></span><br><span class="line">model = build_model(dense_units=<span class="number">256</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">  </span><br><span class="line">model.fit(train_batches, </span><br><span class="line">          epochs=<span class="number">50</span>, </span><br><span class="line">          validation_data=validation_batches, </span><br><span class="line">          verbose=<span class="number">2</span>,</span><br><span class="line">          callbacks=[EarlyStopping(</span><br><span class="line">              patience=<span class="number">3</span>,</span><br><span class="line">              min_delta=<span class="number">0.05</span>,</span><br><span class="line">              baseline=<span class="number">0.8</span>,</span><br><span class="line">              mode=<span class="string">&#x27;min&#x27;</span>,</span><br><span class="line">              monitor=<span class="string">&#x27;val_loss&#x27;</span>,</span><br><span class="line">              restore_best_weights=<span class="literal">True</span>,</span><br><span class="line">              verbose=<span class="number">1</span>)</span><br><span class="line">          ])</span><br><span class="line"></span><br><span class="line"><span class="comment">#CSVLogger</span></span><br><span class="line">model = build_model(dense_units=<span class="number">256</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">  </span><br><span class="line">csv_file = <span class="string">&#x27;training.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">model.fit(train_batches, </span><br><span class="line">          epochs=<span class="number">5</span>, </span><br><span class="line">          validation_data=validation_batches, </span><br><span class="line">          callbacks=[CSVLogger(csv_file)</span><br><span class="line">          ])</span><br><span class="line"></span><br><span class="line"><span class="comment">#LearningRateScheduler</span></span><br><span class="line">model = build_model(dense_units=<span class="number">256</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">step_decay</span>(<span class="params">epoch</span>):</span></span><br><span class="line">	initial_lr = <span class="number">0.01</span></span><br><span class="line">	drop = <span class="number">0.5</span></span><br><span class="line">	epochs_drop = <span class="number">1</span></span><br><span class="line">	lr = initial_lr * math.<span class="built_in">pow</span>(drop, math.floor((<span class="number">1</span>+epoch)/epochs_drop))</span><br><span class="line">	<span class="keyword">return</span> lr</span><br><span class="line"></span><br><span class="line">model.fit(train_batches, </span><br><span class="line">          epochs=<span class="number">5</span>, </span><br><span class="line">          validation_data=validation_batches, </span><br><span class="line">          callbacks=[LearningRateScheduler(step_decay, verbose=<span class="number">1</span>),</span><br><span class="line">                    TensorBoard(log_dir=<span class="string">&#x27;./log_dir&#x27;</span>)]) <span class="comment"># 以上介绍的callbacks可以传递多个item</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ReduceLROnPlateau</span></span><br><span class="line">model = build_model(dense_units=<span class="number">256</span>)</span><br><span class="line">model.<span class="built_in">compile</span>(</span><br><span class="line">    optimizer=<span class="string">&#x27;sgd&#x27;</span>,</span><br><span class="line">    loss=<span class="string">&#x27;sparse_categorical_crossentropy&#x27;</span>, </span><br><span class="line">    metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br><span class="line">  </span><br><span class="line">model.fit(train_batches, </span><br><span class="line">          epochs=<span class="number">50</span>, </span><br><span class="line">          validation_data=validation_batches, </span><br><span class="line">          callbacks=[ReduceLROnPlateau(monitor=<span class="string">&#x27;val_loss&#x27;</span>, </span><br><span class="line">                                       factor=<span class="number">0.2</span>, verbose=<span class="number">1</span>,</span><br><span class="line">                                       patience=<span class="number">1</span>, min_lr=<span class="number">0.001</span>),</span><br><span class="line">                     TensorBoard(log_dir=<span class="string">&#x27;./log_dir&#x27;</span>)])</span><br></pre></td></tr></table></figure>
<h3 id="自定义callbacks">自定义callbacks</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DetectOverfittingCallback</span>(<span class="params">tf.keras.callbacks.Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threshold=<span class="number">0.7</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(DetectOverfittingCallback, self).__init__()</span><br><span class="line">        self.threshold = threshold</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span>(<span class="params">self, epoch, logs=<span class="literal">None</span></span>):</span></span><br><span class="line">        ratio = logs[<span class="string">&quot;val_loss&quot;</span>] / logs[<span class="string">&quot;loss&quot;</span>]</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Epoch: &#123;&#125;, Val/Train loss ratio: &#123;:.2f&#125;&quot;</span>.<span class="built_in">format</span>(epoch, ratio))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ratio &gt; self.threshold:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Stopping training...&quot;</span>)</span><br><span class="line">            self.model.stop_training = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">model = get_model()</span><br><span class="line">_ = model.fit(x_train, y_train,</span><br><span class="line">              validation_data=(x_test, y_test),</span><br><span class="line">              batch_size=<span class="number">64</span>,</span><br><span class="line">              epochs=<span class="number">3</span>,</span><br><span class="line">              verbose=<span class="number">0</span>,</span><br><span class="line">              callbacks=[DetectOverfittingCallback()])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在tf.keras.callbacks.Callback类中还可以重写的函数还有：</p>
<h4 id="on_traintestpredict_beginself-logsnone"><code>on_(train|test|predict)_begin(self, logs=None)</code></h4>
<p>Called at the beginning of
<code>fit</code>/<code>evaluate</code>/<code>predict</code>.</p>
<h4 id="on_traintestpredict_endself-logsnone"><code>on_(train|test|predict)_end(self, logs=None)</code></h4>
<p>Called at the end of
<code>fit</code>/<code>evaluate</code>/<code>predict</code>.</p>
<h4 id="on_traintestpredict_batch_beginself-batch-logsnone"><code>on_(train|test|predict)_batch_begin(self, batch, logs=None)</code></h4>
<p>Called right before processing a batch during
training/testing/predicting. Within this method, <code>logs</code> is a
dict with <code>batch</code> and <code>size</code> available keys,
representing the current batch number and the size of the batch.</p>
<p>logs是一个字典，keys=[batch,size]，分别表示batch number和batch
size</p>
<h4 id="on_traintestpredict_batch_endself-batch-logsnone"><code>on_(train|test|predict)_batch_end(self, batch, logs=None)</code></h4>
<p>Called at the end of training/testing/predicting a batch. Within this
method, <code>logs</code> is a dict containing the stateful metrics
result.</p>
<p>这里的Logs字典中含有metrics结果</p>
<h3 id="training-specific-methods">Training specific methods</h3>
<p>在训练阶段有一些特别的函数：</p>
<h4 id="on_epoch_beginself-epoch-logsnone"><code>on_epoch_begin(self, epoch, logs=None)</code></h4>
<p>Called at the beginning of an epoch during training.</p>
<h4 id="on_epoch_endself-epoch-logsnone"><code>on_epoch_end(self, epoch, logs=None)</code></h4>
<p>Called at the end of an epoch during training.</p>
<p>可以在自定义callback类中定义display结果的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visualization utilities</span></span><br><span class="line">plt.rc(<span class="string">&#x27;font&#x27;</span>, size=<span class="number">20</span>)</span><br><span class="line">plt.rc(<span class="string">&#x27;figure&#x27;</span>, figsize=(<span class="number">15</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_digits</span>(<span class="params">inputs, outputs, ground_truth, epoch, n=<span class="number">10</span></span>):</span></span><br><span class="line">    plt.clf() <span class="comment"># clear the current figure</span></span><br><span class="line"></span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.grid(<span class="literal">None</span>)</span><br><span class="line">    inputs = np.reshape(inputs, [n, <span class="number">28</span>, <span class="number">28</span>])</span><br><span class="line">    inputs = np.swapaxes(inputs, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">    inputs = np.reshape(inputs, [<span class="number">28</span>, <span class="number">28</span>*n])</span><br><span class="line">    plt.imshow(inputs)</span><br><span class="line">    plt.xticks([<span class="number">28</span>*x+<span class="number">14</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(n)], outputs)</span><br><span class="line">    <span class="keyword">for</span> i,t <span class="keyword">in</span> <span class="built_in">enumerate</span>(plt.gca().xaxis.get_ticklabels()):</span><br><span class="line">        <span class="keyword">if</span> outputs[i] == ground_truth[i]: </span><br><span class="line">            t.set_color(<span class="string">&#x27;green&#x27;</span>) </span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            t.set_color(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    plt.grid(<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">GIF_PATH = <span class="string">&#x27;./animation.gif&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VisCallback</span>(<span class="params">tf.keras.callbacks.Callback</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, inputs, ground_truth, display_freq=<span class="number">10</span>, n_samples=<span class="number">10</span></span>):</span></span><br><span class="line">        self.inputs = inputs</span><br><span class="line">        self.ground_truth = ground_truth</span><br><span class="line">        self.images = []</span><br><span class="line">        self.display_freq = display_freq</span><br><span class="line">        self.n_samples = n_samples</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span>(<span class="params">self, epoch, logs=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="comment"># Randomly sample data</span></span><br><span class="line">        indexes = np.random.choice(<span class="built_in">len</span>(self.inputs), size=self.n_samples)</span><br><span class="line">        X_test, y_test = self.inputs[indexes], self.ground_truth[indexes]</span><br><span class="line">        predictions = np.argmax(self.model.predict(X_test), axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Plot the digits</span></span><br><span class="line">        display_digits(X_test, predictions, y_test, epoch, n=self.display_freq)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Save the figure</span></span><br><span class="line">        buf = io.BytesIO()</span><br><span class="line">        plt.savefig(buf, <span class="built_in">format</span>=<span class="string">&#x27;png&#x27;</span>)</span><br><span class="line">        buf.seek(<span class="number">0</span>)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(buf)</span><br><span class="line">        self.images.append(np.array(image))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Display the digits every &#x27;display_freq&#x27; number of epochs</span></span><br><span class="line">        <span class="keyword">if</span> epoch % self.display_freq == <span class="number">0</span>:</span><br><span class="line">            plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_train_end</span>(<span class="params">self, logs=<span class="literal">None</span></span>):</span></span><br><span class="line">        imageio.mimsave(GIF_PATH, self.images, fps=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h1 id="course-2-custom-and-distributed-training-with-tensorflow">Course
2 : Custom and Distributed Training with Tensorflow</h1>
<h2 id="导数的计算">导数的计算</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">x = tf.Variable(<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape_2:</span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape_1:</span><br><span class="line">        y = x * x * x</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># The first gradient calculation should occur at leaset</span></span><br><span class="line">    <span class="comment"># within the outer with block</span></span><br><span class="line">    dy_dx = tape_1.gradient(y, x)</span><br><span class="line">d2y_dx2 = tape_2.gradient(dy_dx, x)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dy_dx)</span><br><span class="line"><span class="built_in">print</span>(d2y_dx2)</span><br></pre></td></tr></table></figure>
<h2 id="在fashion-mnist-数据集上写specific的训练过程">在fashion mnist
数据集上写specific的训练过程</h2>
<p>这种训练方式不采用model.fit()的方式去训练模型，而是采用自己写传递导数的方式。增加了灵活度，方便后续进行分布式训练。</p>
<figure>
<img src="/2022/08/30/TensorFlow-Advanced-Techniques-Specialization%E4%B8%93%E9%A1%B9%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/Users\320150117\AppData\Roaming\Typora\typora-user-images\image-20220830150121062.png" alt="image-20220830150121062">
<figcaption aria-hidden="true">image-20220830150121062</figcaption>
</figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.losses <span class="keyword">import</span> SparseCategoricalCrossentropy</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.metrics <span class="keyword">import</span> SparseCategoricalAccuracy</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> Adam</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">base_model</span>():</span></span><br><span class="line">    <span class="built_in">input</span>  = Input(shape=(<span class="number">28</span>*<span class="number">28</span> , ) , name = <span class="string">&quot;input_layer&quot;</span>)</span><br><span class="line">    x = Dense(<span class="number">64</span> , activation=<span class="string">&#x27;relu&#x27;</span> , name = <span class="string">&quot;dense1&quot;</span>)(<span class="built_in">input</span>)</span><br><span class="line">    x = Dense(<span class="number">64</span> , activation=<span class="string">&#x27;relu&#x27;</span> , name = <span class="string">&quot;dense2&quot;</span>)(x)</span><br><span class="line">    output = Dense(<span class="number">10</span> , activation=<span class="string">&#x27;softmax&#x27;</span> , name=<span class="string">&quot;output_layer&quot;</span>)(x)</span><br><span class="line">    model = Model(inputs = <span class="built_in">input</span> , outputs = output)</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_optimizer</span>(<span class="params">model , x , y_true</span>):</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        logits = model(x)</span><br><span class="line">        loss_val = loss_obj(y_true=y_true , y_pred=logits)</span><br><span class="line">    grad = tape.gradient(loss_val , model.trainable_weights) <span class="comment"># model有6个可以train的weights</span></span><br><span class="line">    optimizer_obj.apply_gradients(<span class="built_in">zip</span>(grad , model.trainable_weights))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logits , loss_val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_one_epoch</span>(<span class="params">model , train_data</span>):</span> <span class="comment"># 这里输入的是整个dataset</span></span><br><span class="line">    losses = []</span><br><span class="line">    pbar = tqdm(total=<span class="built_in">len</span>(<span class="built_in">list</span>(<span class="built_in">enumerate</span>(train_data))), position=<span class="number">0</span>, leave=<span class="literal">True</span>, bar_format=<span class="string">&#x27;&#123;l_bar&#125;&#123;bar&#125;| &#123;n_fmt&#125;/&#123;total_fmt&#125; &#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> batch_no , (data , label) <span class="keyword">in</span> <span class="built_in">enumerate</span>(train_data): <span class="comment"># 这个for循环循环的是batch，每次输入模型中训练的是一个batch_size的数据</span></span><br><span class="line">        y_pred , loss = run_optimizer(model , data , label)</span><br><span class="line">        losses.append(loss)</span><br><span class="line">        train_acc_matrix(label , y_pred)</span><br><span class="line">        pbar.set_description(<span class="string">&quot;Training loss for step %s: %.4f&quot;</span> % (<span class="built_in">int</span>(batch_no), <span class="built_in">float</span>(loss)))</span><br><span class="line">        pbar.update()</span><br><span class="line">    <span class="keyword">return</span> losses <span class="comment"># 返回的是一个list，每一个item是一个batch的loss</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">perform_validation</span>(<span class="params">model , test_data</span>):</span></span><br><span class="line">    losses = []</span><br><span class="line">    <span class="keyword">for</span> (data , label) <span class="keyword">in</span> test_data:</span><br><span class="line">        y_pred = model(data)</span><br><span class="line">        loss = loss_obj(label , y_pred)</span><br><span class="line">        losses.append(loss)</span><br><span class="line">        val_acc_matrix(label , y_pred)</span><br><span class="line">    <span class="keyword">return</span> losses</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train</span>(<span class="params">train , test , epochs = <span class="number">10</span></span>):</span></span><br><span class="line">    model = base_model()</span><br><span class="line"></span><br><span class="line">    history = &#123;&#125;</span><br><span class="line">    history[<span class="string">&#x27;train_loss&#x27;</span>] = []</span><br><span class="line">    history[<span class="string">&#x27;val_loss&#x27;</span>] = []</span><br><span class="line"></span><br><span class="line">    history[<span class="string">&#x27;train_acc&#x27;</span>] = []</span><br><span class="line">    history[<span class="string">&#x27;val_acc&#x27;</span>] = []</span><br><span class="line"></span><br><span class="line">    val_epoch_loss   = []</span><br><span class="line">    <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(epochs):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start of epoch %d&#x27;</span> % (epoch,))</span><br><span class="line"></span><br><span class="line">        train_losses = train_one_epoch(model , train_data=train)</span><br><span class="line">        train_acc    = train_acc_matrix.result()</span><br><span class="line">        history[<span class="string">&#x27;train_acc&#x27;</span>].append(train_acc.numpy())</span><br><span class="line">        train_acc_matrix.reset_states()</span><br><span class="line"></span><br><span class="line">        val_losses   = perform_validation(model , test_data=test)</span><br><span class="line">        val_acc      = val_acc_matrix.result()</span><br><span class="line">        history[<span class="string">&#x27;val_acc&#x27;</span>].append(val_acc.numpy())</span><br><span class="line">        val_acc_matrix.reset_states()</span><br><span class="line"></span><br><span class="line">        history[<span class="string">&#x27;train_loss&#x27;</span>].append(np.mean(train_losses)) <span class="comment"># 这里求解的是所有batch的loss总和求平均</span></span><br><span class="line">        history[<span class="string">&#x27;val_loss&#x27;</span>].append(np.mean(val_losses))</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\n Epoch %s: Train loss: %.4f  Validation Loss: %.4f,\</span></span><br><span class="line"><span class="string">         Train Accuracy: %.4f, Validation Accuracy %.4f&#x27;</span> % (epoch, <span class="built_in">float</span>(np.mean(train_losses)), <span class="built_in">float</span>(np.mean(val_losses)),</span><br><span class="line">                                                            <span class="built_in">float</span>(train_acc), <span class="built_in">float</span>(val_acc)))</span><br><span class="line"></span><br><span class="line">    history[<span class="string">&#x27;model&#x27;</span>] = model</span><br><span class="line">    <span class="keyword">return</span> history</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">loss_obj       = SparseCategoricalCrossentropy()</span><br><span class="line">optimizer_obj  = Adam()</span><br><span class="line"></span><br><span class="line">train_acc_matrix = SparseCategoricalAccuracy()</span><br><span class="line">val_acc_matrix   = SparseCategoricalAccuracy()</span><br><span class="line"></span><br><span class="line">history = train(train_data , test_data)</span><br></pre></td></tr></table></figure>
<h2 id="分布式训练">分布式训练</h2>
<h3 id="mirrored-strategy">Mirrored strategy</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">strategy = tf.distribute.MirroredStrategy() </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Number of devices: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(strategy.num_replicas_in_sync))</span><br><span class="line"></span><br><span class="line">BATCH_SIZE_PER_REPLICA = <span class="number">64</span></span><br><span class="line"><span class="comment"># Use for Mirrored Strategy</span></span><br><span class="line">BATCH_SIZE = BATCH_SIZE_PER_REPLICA * strategy.num_replicas_in_sync</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the train and eval data set</span></span><br><span class="line">train_dataset = mnist_train.<span class="built_in">map</span>(scale).cache().shuffle(BUFFER_SIZE).batch(BATCH_SIZE)</span><br><span class="line">eval_dataset = mnist_test.<span class="built_in">map</span>(scale).batch(BATCH_SIZE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Use for Mirrored Strategy -- comment out `with strategy.scope():` and deindent for no strategy</span></span><br><span class="line"><span class="keyword">with</span> strategy.scope():</span><br><span class="line">    model = tf.keras.Sequential([</span><br><span class="line">      tf.keras.layers.Conv2D(<span class="number">32</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=(<span class="number">28</span>, <span class="number">28</span>, <span class="number">1</span>)),</span><br><span class="line">      tf.keras.layers.MaxPooling2D(),</span><br><span class="line">      tf.keras.layers.Flatten(),</span><br><span class="line">      tf.keras.layers.Dense(<span class="number">64</span>, activation=<span class="string">&#x27;relu&#x27;</span>),</span><br><span class="line">      tf.keras.layers.Dense(<span class="number">10</span>)</span><br><span class="line">    ])</span><br><span class="line">model.<span class="built_in">compile</span>(loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=<span class="literal">True</span>),</span><br><span class="line">                optimizer=tf.keras.optimizers.Adam(),</span><br><span class="line">                metrics=[<span class="string">&#x27;accuracy&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>这种方式会使用该机器的所有gpu,如果想指定使用的GPU可以使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gpus = tf.config.experimental.list_logical_devices(<span class="string">&quot;GPU&quot;</span>)</span><br><span class="line"><span class="comment"># gpus = tf.config.list_physical_devices(&#x27;GPU&#x27;)</span></span><br><span class="line">strategy = tf.distribute.MirroredStrategy([gpu.name <span class="keyword">for</span> gpu <span class="keyword">in</span> gpus])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Running on multiple GPUs &#x27;</span>, [gpu.name <span class="keyword">for</span> gpu <span class="keyword">in</span> gpus])</span><br></pre></td></tr></table></figure>
<h1 id="course-3-advanced-computer-vision-with-tensorflow">Course 3:
Advanced Computer Vision with Tensorflow</h1>
<h2 id="object-localization">Object Localization</h2>
<p>week1介绍了transfer
learning和利用minist手写体数据集做的一个简单的物体定位+分类的模型。object
localization和object
detection的区别在于后者需要识别出image中所有物体的Box并能实现分类，而前者只是需要检测出最主要的那个object并分类。可参考博客https://towardsdatascience.com/object-localization-in-overfeat-5bb2f7328b62。</p>
<figure>
<img src="https://miro.medium.com/max/1400/1*LOjfqvJ0zDuSSq443Z9SNA.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h2 id="object-detection">Object Detection</h2>
<p>如果想要开箱即用的方式，作者介绍了tensorflow的API进行调用：https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/tf2.md。在该object
detection写好的API下有几个可用的utils可以使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> viz_utils</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> ops <span class="keyword">as</span> utils_ops <span class="comment"># 在image segmentation中有使用到mask</span></span><br><span class="line"></span><br><span class="line">PATH_TO_LABELS = <span class="string">&#x27;./models/research/object_detection/data/mscoco_label_map.pbtxt&#x27;</span></span><br><span class="line">category_index = label_map_util.create_category_index_from_labelmap(PATH_TO_LABELS) <span class="comment"># category_index是一个字典，key为unique id，values也是一个字典：key是index，value是label_name</span></span><br><span class="line"></span><br><span class="line">viz_utils.visualize_boxes_and_labels_on_image_array(</span><br><span class="line">    image_np_with_detections[<span class="number">0</span>],</span><br><span class="line">    result[<span class="string">&#x27;detection_boxes&#x27;</span>][<span class="number">0</span>],</span><br><span class="line">    (result[<span class="string">&#x27;detection_classes&#x27;</span>][<span class="number">0</span>] + label_id_offset).astype(<span class="built_in">int</span>),</span><br><span class="line">    result[<span class="string">&#x27;detection_scores&#x27;</span>][<span class="number">0</span>],</span><br><span class="line">    category_index,</span><br><span class="line">    use_normalized_coordinates=<span class="literal">True</span></span><br><span class="line">) <span class="comment"># images,boxes,classes,scores</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外还介绍了在已有weights上finetune模型的方法。使用的例子是tensorflow官方出的tutorial。https://github.com/tensorflow/models/blob/master/research/object_detection/colab_tutorials/eager_few_shot_od_training_tf2_colab.ipynb</p>
<h3 id="补充介绍object-detection">补充介绍object detection</h3>
<p>这里我又去翻阅了一些review的文章，想了解一下在物体检测领域的其他算法。参考文章
Object Detection With Deep Learning: A Review.</p>
<figure>
<img src="/2022/08/30/TensorFlow-Advanced-Techniques-Specialization%E4%B8%93%E9%A1%B9%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/Users\320150117\AppData\Roaming\Typora\typora-user-images\image-20220913152542940.png" alt="image-20220913152542940">
<figcaption aria-hidden="true">image-20220913152542940</figcaption>
</figure>
<p>该文章将物体检测领域的模型分为两个种类，第一类就是以R-CNN为代表的region
proposal方法，第二类就是遵循一个统一的模式，将其看成是一个regression/classification的问题.</p>
<ol type="1">
<li>region proposal</li>
</ol>
<p>R-CNN,
SPP-net(在R-CNN基础上进行了改进)，Fast-RCNN，Faster-RCNN，R-FCN。</p>
<ol type="1">
<li>regression/classification based</li>
</ol>
<p>MultiBox，AttentionNet，G-CNN，yolo，SSD（single shot Multibox
detector）</p>
<h2 id="image-segmentation">image segmentation</h2>
<p>除了FCN-8和Unet。作者还介绍了Mask-RCNN。</p>
<h2 id="可解释性">可解释性</h2>
<p>Class Activation Map : A class activation map is a matrix that shows
what parts of the image the model was paying attention to when deciding
what class to assign the image.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/alexisbcook/ResNetCAM-keras/blob/master/ResNet_CAM.py">代码地址</a></p>
<p><a target="_blank" rel="noopener" href="https://alexisbcook.github.io/2017/global-average-pooling-layers-for-object-localization/#:~:text=to%20avoid%20overfitting.-,Global%20Average%20Pooling,of%20a%20three-dimensional%20tensor.">代码博客</a></p>
<p><a target="_blank" rel="noopener" href="https://towardsdatascience.com/class-activation-mapping-using-transfer-learning-of-resnet50-e8ca7cfd657e">参考博客</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> ast</span><br><span class="line"><span class="keyword">import</span> scipy   </span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> cv2     </span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.applications.resnet50 <span class="keyword">import</span> ResNet50, preprocess_input</span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.preprocessing <span class="keyword">import</span> image    </span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.models <span class="keyword">import</span> Model   </span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pretrained_path_to_tensor</span>(<span class="params">img_path</span>):</span></span><br><span class="line">    <span class="comment"># loads RGB image as PIL.Image.Image type</span></span><br><span class="line">    img = image.load_img(img_path, target_size=(<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">    <span class="comment"># convert PIL.Image.Image type to 3D tensor with shape (224, 224, 3)</span></span><br><span class="line">    x = image.img_to_array(img)</span><br><span class="line">    <span class="comment"># convert 3D tensor to 4D tensor with shape (1, 224, 224, 3) and return 4D tensor</span></span><br><span class="line">    x = np.expand_dims(x, axis=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># convert RGB -&gt; BGR, subtract mean ImageNet pixel, and return 4D tensor</span></span><br><span class="line">    <span class="keyword">return</span> preprocess_input(x)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ResNet</span>():</span></span><br><span class="line">    <span class="comment"># define ResNet50 model</span></span><br><span class="line">    model = ResNet50(weights=<span class="string">&#x27;imagenet&#x27;</span>)</span><br><span class="line">    <span class="comment"># model.summary()</span></span><br><span class="line">    <span class="comment"># get AMP layer weights (2048,1000)</span></span><br><span class="line">    all_amp_layer_weights = model.layers[-<span class="number">1</span>].get_weights()[<span class="number">0</span>] <span class="comment"># 这里get_weights()返回的是一个list,list[0]是kernel matrix,list[1]是bias</span></span><br><span class="line">    <span class="comment"># extract wanted output</span></span><br><span class="line">    ResNet_model = Model(inputs=model.<span class="built_in">input</span>, </span><br><span class="line">        outputs=(model.layers[-<span class="number">4</span>].output, model.layers[-<span class="number">1</span>].output)) </span><br><span class="line">    <span class="keyword">return</span> ResNet_model, all_amp_layer_weights</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ResNet_CAM</span>(<span class="params">img_path, model, all_amp_layer_weights</span>):</span></span><br><span class="line">    <span class="comment"># get filtered images from convolutional output + model prediction vector</span></span><br><span class="line">    last_conv_output, pred_vec = model.predict(pretrained_path_to_tensor(img_path))</span><br><span class="line">    <span class="comment"># change dimensions of last convolutional outpu tto 7 x 7 x 2048</span></span><br><span class="line">    last_conv_output = np.squeeze(last_conv_output) </span><br><span class="line">    <span class="comment"># get model&#x27;s prediction (number between 0 and 999, inclusive)</span></span><br><span class="line">    pred = np.argmax(pred_vec)</span><br><span class="line">    <span class="comment"># bilinear upsampling to resize each filtered image to size of original image </span></span><br><span class="line">    mat_for_mult = scipy.ndimage.zoom(last_conv_output, (<span class="number">32</span>, <span class="number">32</span>, <span class="number">1</span>), order=<span class="number">1</span>) <span class="comment"># dim: 224 x 224 x 2048</span></span><br><span class="line">    <span class="comment"># get AMP layer weights</span></span><br><span class="line">    amp_layer_weights = all_amp_layer_weights[:, pred] <span class="comment"># dim: (2048,) </span></span><br><span class="line">    <span class="comment"># get class activation map for object class that is predicted to be in the image</span></span><br><span class="line">    final_output = np.dot(mat_for_mult.reshape((<span class="number">224</span>*<span class="number">224</span>, <span class="number">2048</span>)), amp_layer_weights).reshape(<span class="number">224</span>,<span class="number">224</span>) <span class="comment"># dim: 224 x 224</span></span><br><span class="line">    <span class="comment"># return class activation map</span></span><br><span class="line">    <span class="keyword">return</span> final_output, pred</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_ResNet_CAM</span>(<span class="params">img_path, ax, model, all_amp_layer_weights</span>):</span></span><br><span class="line">    <span class="comment"># load image, convert BGR --&gt; RGB, resize image to 224 x 224,</span></span><br><span class="line">    im = cv2.resize(cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB), (<span class="number">224</span>, <span class="number">224</span>))</span><br><span class="line">    <span class="comment"># plot image</span></span><br><span class="line">    ax.imshow(im, alpha=<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># get class activation map</span></span><br><span class="line">    CAM, pred = ResNet_CAM(img_path, model, all_amp_layer_weights)</span><br><span class="line">    <span class="comment"># plot class activation map</span></span><br><span class="line">    ax.imshow(CAM, cmap=<span class="string">&#x27;jet&#x27;</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line">    <span class="comment"># load the dictionary that identifies each ImageNet category to an index in the prediction vector</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;imagenet1000_clsid_to_human.txt&#x27;</span>) <span class="keyword">as</span> imagenet_classes_file:</span><br><span class="line">        imagenet_classes_dict = ast.literal_eval(imagenet_classes_file.read())</span><br><span class="line">    <span class="comment"># obtain the predicted ImageNet category</span></span><br><span class="line">    ax.set_title(imagenet_classes_dict[pred]) </span><br><span class="line"></span><br><span class="line">ResNet_model, all_amp_layer_weights = get_ResNet()</span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line">CAM = plot_ResNet_CAM(img_path, ax, ResNet_model, all_amp_layer_weights)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>Saliency Maps：see where the pixels that were most impactful to the
final classification were found.
显示的是哪些pixel会对最终的分类结果造成重大影响。</p>
<p>Grad-CAM Map：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">gradModel = Model(inputs=[model.inputs],outputs[model.get_layer(layer_name).output,model.output])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">   <span class="comment"># cast the image tensor to a float-32 data type, pass the</span></span><br><span class="line">   <span class="comment"># forward propagate the image through the gradient model, and grab the loss</span></span><br><span class="line">   <span class="comment"># associated with the specific class index</span></span><br><span class="line">   inputs = tf.cast(img_array, tf.float32)</span><br><span class="line">   (convOutputs, predictions) = gradModel(inputs)</span><br><span class="line">   loss = predictions[:, <span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># use automatic differentiation to compute the gradients</span></span><br><span class="line">grads = tape.gradient(loss, convOutputs)</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute the guided gradients</span></span><br><span class="line">castConvOutputs = tf.cast(convOutputs &gt; <span class="number">0</span>, <span class="string">&quot;float32&quot;</span>)</span><br><span class="line">castGrads = tf.cast(grads &gt; <span class="number">0</span>, <span class="string">&quot;float32&quot;</span>)</span><br><span class="line">guidedGrads = castConvOutputs * castGrads * grads</span><br><span class="line"></span><br><span class="line"><span class="comment"># the convolution and guided gradients have a batch dimension</span></span><br><span class="line"><span class="comment"># (which we don&#x27;t need) so let&#x27;s grab the volume itself and</span></span><br><span class="line"><span class="comment"># discard the batch</span></span><br><span class="line">convOutputs = convOutputs[<span class="number">0</span>]</span><br><span class="line">guidedGrads = guidedGrads[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute the average of the gradient values, and using them</span></span><br><span class="line"><span class="comment"># as weights, compute the ponderation of the filters with</span></span><br><span class="line"><span class="comment"># respect to the weights</span></span><br><span class="line">weights = tf.reduce_mean(guidedGrads, axis=(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">cam = tf.reduce_sum(tf.multiply(weights, convOutputs), axis=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># grab the spatial dimensions of the input image and resize</span></span><br><span class="line"><span class="comment"># the output class activation map to match the input image</span></span><br><span class="line"><span class="comment"># dimensions</span></span><br><span class="line">(w, h) = (img_array.shape[<span class="number">2</span>], img_array.shape[<span class="number">1</span>])</span><br><span class="line">heatmap = cv2.resize(cam.numpy(), (w, h))</span><br><span class="line"></span><br><span class="line"><span class="comment"># normalize the heatmap such that all values lie in the range</span></span><br><span class="line"><span class="comment"># [0, 1], scale the resulting values to the range [0, 255],</span></span><br><span class="line"><span class="comment"># and then convert to an unsigned 8-bit integer</span></span><br><span class="line">numer = heatmap - np.<span class="built_in">min</span>(heatmap)</span><br><span class="line">denom = (heatmap.<span class="built_in">max</span>() - heatmap.<span class="built_in">min</span>()) + eps</span><br><span class="line">heatmap = numer / denom</span><br></pre></td></tr></table></figure>
<h1 id="course-4-gans">Course 4: GANs</h1>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/29/%E5%8D%B7%E7%A7%AF%E5%92%8C%E5%8F%8D%E5%8D%B7%E7%A7%AF%E4%B8%AD%E7%9A%84output-shape%E8%AE%A1%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="YAN">
      <meta itemprop="description" content="Be smart! Keep Learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YAN's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/29/%E5%8D%B7%E7%A7%AF%E5%92%8C%E5%8F%8D%E5%8D%B7%E7%A7%AF%E4%B8%AD%E7%9A%84output-shape%E8%AE%A1%E7%AE%97/" class="post-title-link" itemprop="url">卷积和反卷积中的output shape计算</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-29 14:30:31" itemprop="dateCreated datePublished" datetime="2022-08-29T14:30:31+08:00">2022-08-29</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-23 11:57:03" itemprop="dateModified" datetime="2023-02-23T11:57:03+08:00">2023-02-23</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/computer-vision-cv/" itemprop="url" rel="index"><span itemprop="name">computer vision(cv)</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>2 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="conv2d">Conv2D</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line">input_shape = (<span class="number">4</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">3</span>)</span><br><span class="line">x = tf.random.normal(input_shape)</span><br><span class="line"></span><br><span class="line">y1 = tf.keras.layers.Conv2D(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&#x27;valid&#x27;</span>)(x) <span class="comment"># output_shape= (input_shape - filter_size + 1) * (input_shape - filter_size + 1)</span></span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">26</span>, <span class="number">26</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y2 = tf.keras.layers.Conv2D(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&quot;same&quot;</span>)(x)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y3 = tf.keras.layers.Conv2D(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&quot;valid&quot;</span>,strides=<span class="number">2</span>)(x) </span><br><span class="line"><span class="built_in">print</span>(y.shape) <span class="comment"># output_shape= [(input_shape - filter_size)/strides + 1] * [(input_shape - filter_size)/strides + 1]</span></span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">13</span>, <span class="number">13</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y4 = tf.keras.layers.Conv2D(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&quot;same&quot;</span>,strides=<span class="number">2</span>)(x) </span><br><span class="line"><span class="built_in">print</span>(y.shape) <span class="comment"># output_shape= (input_shape - filter_size + 1) * (input_shape - filter_size + 1)</span></span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">14</span>, <span class="number">14</span>, <span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>上例中输入是<code>(28,28,3)</code>的<code>shape</code>。
我们在推算<code>output shape</code>时要分两种情况：</p>
<ol type="1">
<li><code>padding="valid"</code>:
<code>output_shape= [(input_shape - filter_size)/strides + 1] * [(input_shape - filter_size)/strides + 1]</code>。如果<code>strides</code>除不尽，则向下取整（取比该数小的那个整数）。所以<code>y3</code>的<code>shape</code>是13</li>
<li><code>padding="same"</code>:
当<code>padding="same"</code>时计算很简单，得到的<code>output</code>的<code>shape</code>一定是<code>input_shape/strides</code>。所以当<code>strides=1</code>时，输入和输出的<code>shape</code>时相等的，比如上面的<code>y2</code>。</li>
</ol>
<p>如果需要更细节的原理可以参考<a target="_blank" rel="noopener" href="https://towardsdatascience.com/understand-transposed-convolutions-and-build-your-own-transposed-convolution-layer-from-scratch-4f5d97b2967">博客</a>。这篇文章讲的特别好！重点推荐。</p>
<h1 id="conv2dtranspose">Conv2DTranspose</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">y1 = tf.keras.layers.Conv2DTranspose(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&quot;valid&quot;</span>)(x)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y2 = tf.keras.layers.Conv2DTranspose(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&quot;same&quot;</span>)(x)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">28</span>, <span class="number">28</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y3 = tf.keras.layers.Conv2DTranspose(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&quot;valid&quot;</span>,strides=<span class="number">2</span>)(x)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">57</span>, <span class="number">57</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">y4 = tf.keras.layers.Conv2DTranspose(<span class="number">2</span>, <span class="number">3</span>, activation=<span class="string">&#x27;relu&#x27;</span>, input_shape=input_shape[<span class="number">1</span>:],padding=<span class="string">&quot;same&quot;</span>,strides=<span class="number">2</span>)(x)</span><br><span class="line"><span class="built_in">print</span>(y.shape)</span><br><span class="line">&gt;&gt;(<span class="number">4</span>, <span class="number">56</span>, <span class="number">56</span>, <span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样的总结下这个反卷积我们在推算<code>output shape</code>时也是分两种情况：
1. <code>padding="valid"</code>:
<code>output_length = input_length * stride + max(filter_size - stride, 0)</code>
2. <code>padding="same"</code>:
<code>output_shape=input_shape * strides</code>。当<code>strides=1</code>时，输出<code>shape</code>等于输入<code>shape</code></p>
<p>当<code>padding=valid</code>时的计算有点复杂。再细究一下的话，<code>tensorflow</code>中<code>Conv2DTranspose</code>还接受<code>output_padding</code>这个参数。如果有这个参数的话（默认是None），可以参考<code>tensorflow</code>官方文档给出的<a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Conv2DTranspose">公式</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/23/image-segmentation%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E5%92%8C%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="YAN">
      <meta itemprop="description" content="Be smart! Keep Learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YAN's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/08/23/image-segmentation%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96%E5%92%8C%E5%A4%84%E7%90%86/" class="post-title-link" itemprop="url">image-segmentation图像分割中的数据读取和处理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-08-23 13:20:32" itemprop="dateCreated datePublished" datetime="2022-08-23T13:20:32+08:00">2022-08-23</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">Edited on</span>
        <time title="Modified: 2023-02-08 11:35:57" itemprop="dateModified" datetime="2023-02-08T11:35:57+08:00">2023-02-08</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/computer-vision-cv/" itemprop="url" rel="index"><span itemprop="name">computer vision(cv)</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="Symbols count in article">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">Symbols count in article: </span>
      <span>12k</span>
    </span>
    <span class="post-meta-item" title="Reading time">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">Reading time &asymp;</span>
      <span>11 mins.</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="用tensorflow.image">用tensorflow.image</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">import</span> tensorflow_io <span class="keyword">as</span> tfio</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_image</span>(<span class="params">image_path, mask=<span class="literal">False</span></span>):</span></span><br><span class="line">    image = tf.io.read_file(image_path)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> mask:</span><br><span class="line">        image = tf.image.decode_png(image, channels=<span class="number">1</span>)</span><br><span class="line">        image.set_shape([<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">1</span>])</span><br><span class="line">        image = tf.image.resize(images=image, size=[IMAGE_SIZE, IMAGE_SIZE])</span><br><span class="line">        image = tf.cast(image, tf.int32)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        image = tf.image.decode_png(image, channels=<span class="number">3</span>)</span><br><span class="line">        image.set_shape([<span class="literal">None</span>, <span class="literal">None</span>, <span class="number">3</span>])</span><br><span class="line">        image = tf.image.resize(images=image, size=[IMAGE_SIZE, IMAGE_SIZE])</span><br><span class="line">        image = image / <span class="number">255.</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span>(<span class="params">image_list, mask_list</span>):</span></span><br><span class="line">    image = read_image(image_list)</span><br><span class="line">    mask  = read_image(mask_list, mask=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">return</span> image, mask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_generator</span>(<span class="params">image_list, mask_list, split=<span class="string">&#x27;train&#x27;</span></span>):</span></span><br><span class="line">    dataset = tf.data.Dataset.from_tensor_slices((image_list, mask_list))</span><br><span class="line">    dataset = dataset.shuffle(<span class="number">8</span>*BATCH_SIZE) <span class="keyword">if</span> split == <span class="string">&#x27;train&#x27;</span> <span class="keyword">else</span> dataset </span><br><span class="line">    dataset = dataset.<span class="built_in">map</span>(load_data, num_parallel_calls=tf.data.AUTOTUNE)</span><br><span class="line">    dataset = dataset.batch(BATCH_SIZE, drop_remainder=<span class="literal">True</span>)</span><br><span class="line">    dataset = dataset.prefetch(tf.data.AUTOTUNE)</span><br><span class="line">    <span class="keyword">return</span> dataset</span><br><span class="line"></span><br><span class="line">IMAGE_SIZE = <span class="number">128</span></span><br><span class="line">BATCH_SIZE = <span class="number">86</span></span><br><span class="line"></span><br><span class="line">train_dataset = data_generator(images, masks)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Train Dataset:&quot;</span>, train_dataset)</span><br><span class="line"></span><br><span class="line">input_data = os.path.join(root, <span class="string">&#x27;train_images&#x27;</span>)</span><br><span class="line">images = <span class="built_in">sorted</span>(</span><br><span class="line">    [</span><br><span class="line">        os.path.join(input_data, fname)</span><br><span class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(input_data)</span><br><span class="line">        <span class="keyword">if</span> fname.endswith(exts) <span class="keyword">and</span> <span class="keyword">not</span> fname.startswith(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">target_data = os.path.join(root, <span class="string">&#x27;train_masks&#x27;</span>)</span><br><span class="line">masks = <span class="built_in">sorted</span>(</span><br><span class="line">    [</span><br><span class="line">        os.path.join(target_data, fname)</span><br><span class="line">        <span class="keyword">for</span> fname <span class="keyword">in</span> os.listdir(target_data)</span><br><span class="line">        <span class="keyword">if</span> fname.endswith(exts) <span class="keyword">and</span> <span class="keyword">not</span> fname.startswith(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Number of samples:&quot;</span>, <span class="built_in">len</span>(images), <span class="built_in">len</span>(masks))</span><br><span class="line"><span class="keyword">for</span> input_path, target_path <span class="keyword">in</span> <span class="built_in">zip</span>(images[:<span class="number">10</span>], masks[:<span class="number">10</span>]):</span><br><span class="line">    <span class="built_in">print</span>(input_path[-<span class="number">32</span>:], <span class="string">&quot;|&quot;</span>, target_path[-<span class="number">31</span>:], <span class="string">&#x27;|&#x27;</span>, np.unique(cv2.imread(target_path)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上方式传入data_generator的是image和mask所在图片路径.</p>
<h1 id="用cv2">用cv2</h1>
<p>这种方式适合图片不多的情况下使用，直接读入ndarry里存储。
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">train_img_paths = <span class="built_in">sorted</span>(glob(<span class="string">&#x27;../output/kaggle/working/train/*.jpg&#x27;</span>))[:SAMPLE]</span><br><span class="line">train_mask_paths = <span class="built_in">sorted</span>(glob(<span class="string">&#x27;../output/kaggle/working/train_masks/*.gif&#x27;</span>))[:SAMPLE]</span><br><span class="line"></span><br><span class="line">train_imgs = np.array([cv2.resize(imageio.imread(path), (IMG_ROWS, IMG_COLS))</span><br><span class="line">                        <span class="keyword">for</span> path <span class="keyword">in</span> train_img_paths])</span><br><span class="line"></span><br><span class="line">train_masks = np.array([cv2.resize(imageio.imread(path), (IMG_ROWS, IMG_COLS))</span><br><span class="line">                        <span class="keyword">for</span> path <span class="keyword">in</span> train_mask_paths])</span><br><span class="line"></span><br><span class="line">train_masks = train_masks.astype(np.float32)</span><br><span class="line">train_masks[train_masks&lt;=<span class="number">127</span>] = <span class="number">0.</span></span><br><span class="line">train_masks[train_masks&gt;<span class="number">127</span>] = <span class="number">1.</span></span><br><span class="line">train_masks = np.reshape(train_masks, (*train_masks.shape, <span class="number">1</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="用generator方式">用generator方式</h1>
<p>推荐用这种方式，占用内存小。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">img_paths = <span class="built_in">sorted</span>(glob(<span class="string">&#x27;../output/kaggle/working/train/*.jpg&#x27;</span>))[:<span class="number">500</span>]</span><br><span class="line">mask_paths = <span class="built_in">sorted</span>(glob(<span class="string">&#x27;../output/kaggle/working/train_masks/*.gif&#x27;</span>))[:<span class="number">500</span>]</span><br><span class="line">train_img_files,val_img_files,train_mask_files,val_mask_files = train_test_split(img_paths,mask_paths,test_size=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_mask</span>(<span class="params">masks</span>):</span></span><br><span class="line">    masks[masks&lt;=<span class="number">127</span>] = <span class="number">0.</span></span><br><span class="line">    masks[masks&gt;<span class="number">127</span>] = <span class="number">1.</span></span><br><span class="line">    masks = masks.astype(np.float32)</span><br><span class="line">    masks = np.reshape(masks, (*masks.shape, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> masks</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_img_mask_gen</span>():</span></span><br><span class="line">    <span class="keyword">for</span> img_path,mask_path <span class="keyword">in</span> <span class="built_in">zip</span>(train_img_files,train_mask_files):</span><br><span class="line">        img = cv2.resize(imageio.imread(img_path), (IMG_ROWS, IMG_COLS))</span><br><span class="line">        img = img / <span class="number">127.5</span></span><br><span class="line">        mask = cv2.resize(imageio.imread(mask_path), (IMG_ROWS, IMG_COLS))</span><br><span class="line">        mask = process_mask(mask)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> img, mask</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">val_img_mask_gen</span>():</span></span><br><span class="line">    <span class="keyword">for</span> img_path,mask_path <span class="keyword">in</span> <span class="built_in">zip</span>(val_img_files,val_mask_files):</span><br><span class="line">        img = cv2.resize(imageio.imread(img_path), (IMG_ROWS, IMG_COLS))</span><br><span class="line">        mask = cv2.resize(imageio.imread(mask_path), (IMG_ROWS, IMG_COLS))</span><br><span class="line">        img = img / <span class="number">127.5</span></span><br><span class="line">        mask = process_mask(mask)</span><br><span class="line">        <span class="keyword">yield</span> img, mask</span><br><span class="line"></span><br><span class="line">train_dataset = tf.data.Dataset.from_generator(train_img_mask_gen,</span><br><span class="line">                                              output_signature=(</span><br><span class="line">                                                    tf.TensorSpec(shape=(IMG_ROWS, IMG_COLS, <span class="number">3</span>), dtype=tf.float32),</span><br><span class="line">                                                    tf.TensorSpec(shape=(IMG_ROWS, IMG_COLS, <span class="number">1</span>), dtype=tf.float32))</span><br><span class="line">                                              )</span><br><span class="line">val_dataset = tf.data.Dataset.from_generator(val_img_mask_gen,</span><br><span class="line">                                             output_signature=(</span><br><span class="line">                                                    tf.TensorSpec(shape=(IMG_ROWS, IMG_COLS, <span class="number">3</span>), dtype=tf.float32),</span><br><span class="line">                                                    tf.TensorSpec(shape=(IMG_ROWS, IMG_COLS, <span class="number">1</span>), dtype=tf.float32))</span><br><span class="line">                                            )</span><br></pre></td></tr></table></figure>
上面这种方式需要创建一个generator函数，该函数不接受参数，如果需要传入参数可以另外新建一个函数，该函数会返回一个不接受任何参数的fun().比如：
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">img_masks_generator_from_files</span>(<span class="params">img_files, mask_files, sample_weights=<span class="literal">None</span>, width=<span class="number">512</span>, height=<span class="number">512</span>, shuffle=<span class="literal">True</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sample_weights:</span><br><span class="line">        sample_weights = [[<span class="number">1</span>]] * <span class="built_in">len</span>(img_files) <span class="comment"># Make sample_weights equipped with a broadcastable shape when fed to a tf.Tensor</span></span><br><span class="line">    </span><br><span class="line">    sample_weights = np.array(sample_weights)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sample_weights.shape) == <span class="number">1</span>:</span><br><span class="line">        sample_weights = sample_weights[..., np.newaxis] <span class="comment"># Make sample_weights equipped with a broadcastable shape when fed to a tf.Tensor</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">assert</span>(<span class="built_in">len</span>(sample_weights.shape) == <span class="number">2</span> <span class="keyword">and</span> sample_weights.shape[-<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> shuffle:</span><br><span class="line">        indexes = np.arange(<span class="built_in">len</span>(img_files))</span><br><span class="line">        np.random.shuffle(indexes)</span><br><span class="line">        img_files = [ img_files[i] <span class="keyword">for</span> i <span class="keyword">in</span> indexes ]</span><br><span class="line">        mask_files = [ mask_files[i] <span class="keyword">for</span> i <span class="keyword">in</span> indexes ]</span><br><span class="line">        sample_weights = [ sample_weights[i] <span class="keyword">for</span> i <span class="keyword">in</span> indexes ]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">        <span class="keyword">for</span> img, masks, sample_weight <span class="keyword">in</span> <span class="built_in">zip</span>(img_files, mask_files, sample_weights):</span><br><span class="line">            <span class="keyword">yield</span> img_masks_from_file(img, masks, sample_weight)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> f</span><br><span class="line"></span><br><span class="line">train_img_masks_gen = img_masks_generator_from_files(train_img_files, train_mask_files, train_sample_weights, width=W, height=H)</span><br><span class="line"></span><br><span class="line">train_img_masks_dataset = tf.data.Dataset.from_generator(</span><br><span class="line">    train_img_masks_gen, </span><br><span class="line">    output_signature=(</span><br><span class="line">        tf.TensorSpec(shape=(W, H, <span class="number">1</span>), dtype=tf.float32),</span><br><span class="line">        tf.TensorSpec(shape=(W, H, <span class="built_in">len</span>(train_mask_files[<span class="number">0</span>])), dtype=tf.int32),</span><br><span class="line">        tf.TensorSpec(shape=(<span class="number">1</span>), dtype=tf.float32)</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
上面这种方式还可以换成另一种，在tensorflow.data.Dataset初始化时直接传递args参数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ds_train = tf.data.Dataset.from_generator(noise_generator,args=[<span class="string">&#x27;train&#x27;</span>, mode],output_types=tf.int32,output_shapes=(<span class="literal">None</span>, <span class="literal">None</span>, n_channels))</span><br></pre></td></tr></table></figure>
<p>官方文档是这样写的：</p>
<blockquote>
<p>(Optional.) A tuple of <a target="_blank" rel="noopener" href="https://www.tensorflow.org/api_docs/python/tf/Tensor"><code>tf.Tensor</code></a>
objects that will be evaluated and passed to <code>generator</code> as
NumPy-array arguments.</p>
</blockquote>
<p>关于更多<code>tf.data.Dataset.from_generator</code>的用法可以参考<a target="_blank" rel="noopener" href="https://vak.ai/tensorflow/TensorFlow2.0-dataset/">博客</a>。里面有一句话解答了我的疑惑：</p>
<blockquote>
<p>we need to have a python <a target="_blank" rel="noopener" href="https://www.programiz.com/python-programming/generator">generator</a>
function which generates <strong>one</strong> training pair needed for
our model.</p>
</blockquote>
<p>这就是说我们在创建<code>generator</code>这个函数的时候，函数返回值应该是一个<code>training pair</code>，也就是<code>X</code>和<code>y</code></p>
<hr>
<p>visualize图片的可视化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">visualize</span>(<span class="params">**images</span>):</span> <span class="comment"># **images是(key,item)的方式，*images是item list的方式</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;PLot images in one row.&quot;&quot;&quot;</span></span><br><span class="line">    n = <span class="built_in">len</span>(images)</span><br><span class="line">    plt.figure(figsize=(<span class="number">16</span>, <span class="number">5</span>))</span><br><span class="line">    <span class="keyword">for</span> i, (name, image) <span class="keyword">in</span> <span class="built_in">enumerate</span>(images.items()):</span><br><span class="line">        plt.subplot(<span class="number">1</span>, n, i + <span class="number">1</span>)</span><br><span class="line">        plt.xticks([])</span><br><span class="line">        plt.yticks([])</span><br><span class="line">        plt.title(<span class="string">&#x27; &#x27;</span>.join(name.split(<span class="string">&#x27;_&#x27;</span>)).title())</span><br><span class="line">        plt.imshow(image)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">image, mask = <span class="built_in">next</span>(<span class="built_in">iter</span>(train_dataset.take(<span class="number">1</span>))) <span class="comment"># train_dataset</span></span><br><span class="line"><span class="comment"># image,mask = list(train_dataset.take(1)) </span></span><br><span class="line"><span class="built_in">print</span>(image.shape, mask.shape)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (img, msk) <span class="keyword">in</span> <span class="built_in">zip</span>(image[:<span class="number">5</span>], mask[:<span class="number">5</span>]):</span><br><span class="line">    <span class="built_in">print</span>(mask.numpy().<span class="built_in">min</span>(), mask.numpy().<span class="built_in">max</span>())</span><br><span class="line">    visualize(</span><br><span class="line">        image=img.numpy(),</span><br><span class="line">        gt_mask=msk.numpy(), </span><br><span class="line">    )</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以下是mask标注大于两类（0或者1）的情况下可以观察数据的方式（需要被赋予color）
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Visualization Utilities</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># there are 11 classes in the dataset: one class for each digit (0 to 9) plus the background class</span></span><br><span class="line">n_classes = <span class="number">11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># assign a random color for each class</span></span><br><span class="line">colors = [<span class="built_in">tuple</span>(np.random.randint(<span class="number">256</span>, size=<span class="number">3</span>) / <span class="number">255.0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_classes)]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuse_with_pil</span>(<span class="params">images</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Creates a blank image and pastes input images</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    images (list of numpy arrays) - numpy array representations of the images to paste</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    PIL Image object containing the images</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  widths = (image.shape[<span class="number">1</span>] <span class="keyword">for</span> image <span class="keyword">in</span> images)</span><br><span class="line">  heights = (image.shape[<span class="number">0</span>] <span class="keyword">for</span> image <span class="keyword">in</span> images)</span><br><span class="line">  total_width = <span class="built_in">sum</span>(widths)</span><br><span class="line">  max_height = <span class="built_in">max</span>(heights)</span><br><span class="line"></span><br><span class="line">  new_im = PIL.Image.new(<span class="string">&#x27;RGB&#x27;</span>, (total_width, max_height))</span><br><span class="line"></span><br><span class="line">  x_offset = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> im <span class="keyword">in</span> images:</span><br><span class="line">    pil_image = PIL.Image.fromarray(np.uint8(im))</span><br><span class="line">    new_im.paste(pil_image, (x_offset,<span class="number">0</span>))</span><br><span class="line">    x_offset += im.shape[<span class="number">1</span>]</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> new_im</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">give_color_to_annotation</span>(<span class="params">annotation</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Converts a 2-D annotation to a numpy array with shape (height, width, 3) where</span></span><br><span class="line"><span class="string">  the third axis represents the color channel. The label values are multiplied by</span></span><br><span class="line"><span class="string">  255 and placed in this axis to give color to the annotation</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    annotation (numpy array) - label map array</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Returns:</span></span><br><span class="line"><span class="string">    the annotation array with an additional color channel/axis</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line">  seg_img = np.zeros( (annotation.shape[<span class="number">0</span>],annotation.shape[<span class="number">1</span>], <span class="number">3</span>) ).astype(<span class="string">&#x27;float&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_classes):</span><br><span class="line">    segc = (annotation == c)</span><br><span class="line">    seg_img[:,:,<span class="number">0</span>] += segc*( colors[c][<span class="number">0</span>] * <span class="number">255.0</span>)</span><br><span class="line">    seg_img[:,:,<span class="number">1</span>] += segc*( colors[c][<span class="number">1</span>] * <span class="number">255.0</span>)</span><br><span class="line">    seg_img[:,:,<span class="number">2</span>] += segc*( colors[c][<span class="number">2</span>] * <span class="number">255.0</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> seg_img</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_annotation_and_prediction</span>(<span class="params">image, annotation, prediction, iou_list, dice_score_list</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Displays the images with the ground truth and predicted label maps. Also overlays the metrics.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    image (numpy array) -- the input image</span></span><br><span class="line"><span class="string">    annotation (numpy array) -- the ground truth label map</span></span><br><span class="line"><span class="string">    prediction (numpy array) -- the predicted label map</span></span><br><span class="line"><span class="string">    iou_list (list of floats) -- the IOU values for each class</span></span><br><span class="line"><span class="string">    dice_score_list (list of floats) -- the Dice Score for each class</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  new_ann = np.argmax(annotation, axis=<span class="number">2</span>)</span><br><span class="line">  true_img = give_color_to_annotation(new_ann)</span><br><span class="line">  pred_img = give_color_to_annotation(prediction)</span><br><span class="line"></span><br><span class="line">  image = image + <span class="number">1</span></span><br><span class="line">  image = image * <span class="number">127.5</span></span><br><span class="line">  image = np.reshape(image, (image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>],))</span><br><span class="line">  image = np.uint8(image)</span><br><span class="line">  images = [image, np.uint8(pred_img), np.uint8(true_img)]</span><br><span class="line"></span><br><span class="line">  metrics_by_id = [(idx, iou, dice_score) <span class="keyword">for</span> idx, (iou, dice_score) <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(iou_list, dice_score_list)) <span class="keyword">if</span> iou &gt; <span class="number">0.0</span> <span class="keyword">and</span> idx &lt; <span class="number">10</span>]</span><br><span class="line">  metrics_by_id.sort(key=<span class="keyword">lambda</span> tup: tup[<span class="number">1</span>], reverse=<span class="literal">True</span>)  <span class="comment"># sorts in place</span></span><br><span class="line"></span><br><span class="line">  display_string_list = [<span class="string">&quot;&#123;&#125;: IOU: &#123;&#125; Dice Score: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(idx, iou, dice_score) <span class="keyword">for</span> idx, iou, dice_score <span class="keyword">in</span> metrics_by_id]</span><br><span class="line">  display_string = <span class="string">&quot;\n&quot;</span>.join(display_string_list)</span><br><span class="line"></span><br><span class="line">  plt.figure(figsize=(<span class="number">15</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> idx, im <span class="keyword">in</span> <span class="built_in">enumerate</span>(images):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">3</span>, idx+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> idx == <span class="number">1</span>:</span><br><span class="line">      plt.xlabel(display_string)</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.imshow(im)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_annotation_and_image</span>(<span class="params">image, annotation</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Displays the image and its annotation side by side</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    image (numpy array) -- the input image</span></span><br><span class="line"><span class="string">    annotation (numpy array) -- the label map</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line">  new_ann = np.argmax(annotation, axis=<span class="number">2</span>)</span><br><span class="line">  seg_img = give_color_to_annotation(new_ann)</span><br><span class="line">  </span><br><span class="line">  image = image + <span class="number">1</span></span><br><span class="line">  image = image * <span class="number">127.5</span></span><br><span class="line">  image = np.reshape(image, (image.shape[<span class="number">0</span>], image.shape[<span class="number">1</span>],))</span><br><span class="line"></span><br><span class="line">  image = np.uint8(image)</span><br><span class="line">  images = [image, seg_img]</span><br><span class="line">  </span><br><span class="line">  images = [image, seg_img]</span><br><span class="line">  fused_img = fuse_with_pil(images)</span><br><span class="line">  plt.imshow(fused_img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">list_show_annotation</span>(<span class="params">dataset, num_images</span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  Displays images and its annotations side by side</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  Args:</span></span><br><span class="line"><span class="string">    dataset (tf Dataset) -- batch of images and annotations</span></span><br><span class="line"><span class="string">    num_images (int) -- number of images to display</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br><span class="line">  ds = dataset.unbatch()</span><br><span class="line"></span><br><span class="line">  plt.figure(figsize=(<span class="number">20</span>, <span class="number">15</span>))</span><br><span class="line">  plt.title(<span class="string">&quot;Images And Annotations&quot;</span>)</span><br><span class="line">  plt.subplots_adjust(bottom=<span class="number">0.1</span>, top=<span class="number">0.9</span>, hspace=<span class="number">0.05</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> idx, (image, annotation) <span class="keyword">in</span> <span class="built_in">enumerate</span>(ds.take(num_images)):</span><br><span class="line">    plt.subplot(<span class="number">5</span>, <span class="number">5</span>, idx + <span class="number">1</span>)</span><br><span class="line">    plt.yticks([])</span><br><span class="line">    plt.xticks([])</span><br><span class="line">    show_annotation_and_image(image.numpy(), annotation.numpy())</span><br><span class="line"></span><br><span class="line"><span class="comment"># get 10 images from the training set</span></span><br><span class="line">list_show_annotation(training_dataset, <span class="number">10</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h1 id="segmentation中checkpoint的设置">segmentation中checkpoint的设置</h1>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayCallback</span>(<span class="params">tf.keras.callbacks.Callback</span>):</span> <span class="comment"># 每间隔5个spoch显示一次结果</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dataset, epoch_interval=<span class="number">5</span></span>):</span></span><br><span class="line">        self.dataset = dataset</span><br><span class="line">        self.epoch_interval = epoch_interval</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self, display_list, extra_title=<span class="string">&#x27;&#x27;</span></span>):</span></span><br><span class="line">        plt.figure(figsize=(<span class="number">15</span>, <span class="number">15</span>))</span><br><span class="line">        title = [<span class="string">&#x27;Input Image&#x27;</span>, <span class="string">&#x27;True Mask&#x27;</span>, <span class="string">&#x27;Predicted Mask&#x27;</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(display_list) &gt; <span class="built_in">len</span>(title):</span><br><span class="line">            title.append(extra_title)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(display_list)):</span><br><span class="line">            plt.subplot(<span class="number">1</span>, <span class="built_in">len</span>(display_list), i+<span class="number">1</span>)</span><br><span class="line">            plt.title(title[i])</span><br><span class="line">            plt.imshow(display_list[i])</span><br><span class="line">            plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">create_mask</span>(<span class="params">self, pred_mask</span>):</span></span><br><span class="line">        pred_mask = (pred_mask &gt; <span class="number">0.5</span>).astype(<span class="string">&quot;int32&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> pred_mask[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_predictions</span>(<span class="params">self, dataset, num=<span class="number">1</span></span>):</span></span><br><span class="line">        <span class="keyword">for</span> image, mask <span class="keyword">in</span> dataset.take(num):</span><br><span class="line">            pred_mask = model.predict(image)</span><br><span class="line">            self.display([image[<span class="number">0</span>], mask[<span class="number">0</span>], self.create_mask(pred_mask)])</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_epoch_end</span>(<span class="params">self, epoch, logs=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> epoch <span class="keyword">and</span> epoch % self.epoch_interval == <span class="number">0</span>:</span><br><span class="line">            self.show_predictions(self.dataset)</span><br><span class="line">            <span class="built_in">print</span> (<span class="string">&#x27;\nSample Prediction after epoch &#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(epoch+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">epochs = <span class="number">30</span></span><br><span class="line">model.fit(</span><br><span class="line">    train_dataset, </span><br><span class="line">    epochs=epochs, </span><br><span class="line">    callbacks=[DisplayCallback(train_dataset)]</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>也需要有常规的checkpoint <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.keras.callbacks <span class="keyword">import</span> EarlyStopping, ModelCheckpoint, ReduceLROnPlateau, LearningRateScheduler</span><br><span class="line"></span><br><span class="line">filepath_dice_coeff = <span class="string">&quot;_val_loss.hdf5&quot;</span> <span class="comment"># 保存成一个单独的hdf5文件</span></span><br><span class="line">checkpointer = ModelCheckpoint(filepath_dice_coeff, monitor=<span class="string">&#x27;val_loss&#x27;</span>, verbose=<span class="number">1</span>, save_best_only=<span class="literal">True</span>, mode=<span class="string">&#x27;min&#x27;</span>)<span class="comment"># val_dice_coeff</span></span><br><span class="line">lr_reducer = ReduceLROnPlateau(factor=np.sqrt(<span class="number">0.1</span>), cooldown=<span class="number">0</span>, patience=<span class="number">30</span>, min_lr=<span class="number">0.5e-6</span>)</span><br><span class="line">early_stop = EarlyStopping(monitor=<span class="string">&#x27;val_loss&#x27;</span>, patience=<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">hist = seg_classi_model.fit(train_data,</span><br><span class="line">                steps_per_epoch=(train_imgs.shape[<span class="number">0</span>] + batch_size - <span class="number">1</span>) // batch_size,</span><br><span class="line">                epochs=<span class="number">300</span>,</span><br><span class="line">                callbacks=[checkpointer, lr_reducer, early_stop],</span><br><span class="line">                validation_data=val_data,</span><br><span class="line">                validation_steps=(valid_imgs.shape[<span class="number">0</span>] + batch_size - <span class="number">1</span>) // batch_size) </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YAN</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>Symbols count total: </span>
    <span title="Symbols count total">190k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>Reading time total &asymp;</span>
    <span title="Reading time total">2:53</span>
  </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@next-theme/pjax@0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>



  <script src="/js/third-party/fancybox.js"></script>

  <script src="/js/third-party/pace.js"></script>

  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js","integrity":"sha256-r+3itOMtGGjap0x+10hu6jW/gZCzxHsoKrOd7gyRSGY="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
